// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: rpc-noise.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 2000000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(edb2506a94756af3);
CAPNP_DECLARE_SCHEMA(edc39c3a02a8fdd1);
CAPNP_DECLARE_SCHEMA(de87400d7443e74b);
CAPNP_DECLARE_SCHEMA(fe52c0b506a989fe);
CAPNP_DECLARE_SCHEMA(bff48c8e38a0a259);
CAPNP_DECLARE_SCHEMA(8f5aa1992abf961a);
CAPNP_DECLARE_SCHEMA(e8dbc9a120df5c91);
CAPNP_DECLARE_SCHEMA(a3ddbffc26359181);
CAPNP_DECLARE_SCHEMA(b3bcba4f99bc86fb);
CAPNP_DECLARE_SCHEMA(e44821ae8fb5c580);
CAPNP_DECLARE_SCHEMA(e4bd44206bd515f5);
CAPNP_DECLARE_SCHEMA(bc308e43570d7f84);
CAPNP_DECLARE_SCHEMA(8c20a2967c3f6ce2);
CAPNP_DECLARE_SCHEMA(9aedbbe97b181a4e);

}  // namespace schemas
}  // namespace capnp

namespace capnp {
namespace rpc {
namespace noise {

struct Bytes16 {
  Bytes16() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(edb2506a94756af3, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Bytes32 {
  Bytes32() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(edc39c3a02a8fdd1, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Bytes56 {
  Bytes56() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de87400d7443e74b, 7, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PublicKey {
  PublicKey() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    X25519,
    X448,
  };
  struct X25519;
  struct X448;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe52c0b506a989fe, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PublicKey::X25519 {
  X25519() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bff48c8e38a0a259, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PublicKey::X448 {
  X448() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8f5aa1992abf961a, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatId {
  VatId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8dbc9a120df5c91, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ProvisionId {
  ProvisionId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a3ddbffc26359181, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RecipientId {
  RecipientId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3bcba4f99bc86fb, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatAddress {
  VatAddress() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    IPV6,
    IPV4,
  };
  struct Ipv6;
  struct Ipv4;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e44821ae8fb5c580, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatAddress::Ipv6 {
  Ipv6() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e4bd44206bd515f5, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VatAddress::Ipv4 {
  Ipv4() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bc308e43570d7f84, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ThirdPartyCapId {
  ThirdPartyCapId() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c20a2967c3f6ce2, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct JoinResult {
  JoinResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9aedbbe97b181a4e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Bytes16::Reader {
public:
  typedef Bytes16 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA() const;

  inline  ::uint64_t getB() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bytes16::Builder {
public:
  typedef Bytes16 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA();
  inline void setA( ::uint64_t value);

  inline  ::uint64_t getB();
  inline void setB( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bytes16::Pipeline {
public:
  typedef Bytes16 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Bytes32::Reader {
public:
  typedef Bytes32 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA() const;

  inline  ::uint64_t getB() const;

  inline  ::uint64_t getC() const;

  inline  ::uint64_t getD() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bytes32::Builder {
public:
  typedef Bytes32 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA();
  inline void setA( ::uint64_t value);

  inline  ::uint64_t getB();
  inline void setB( ::uint64_t value);

  inline  ::uint64_t getC();
  inline void setC( ::uint64_t value);

  inline  ::uint64_t getD();
  inline void setD( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bytes32::Pipeline {
public:
  typedef Bytes32 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Bytes56::Reader {
public:
  typedef Bytes56 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA() const;

  inline  ::uint64_t getB() const;

  inline  ::uint64_t getC() const;

  inline  ::uint64_t getD() const;

  inline  ::uint64_t getE() const;

  inline  ::uint64_t getF() const;

  inline  ::uint64_t getG() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bytes56::Builder {
public:
  typedef Bytes56 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getA();
  inline void setA( ::uint64_t value);

  inline  ::uint64_t getB();
  inline void setB( ::uint64_t value);

  inline  ::uint64_t getC();
  inline void setC( ::uint64_t value);

  inline  ::uint64_t getD();
  inline void setD( ::uint64_t value);

  inline  ::uint64_t getE();
  inline void setE( ::uint64_t value);

  inline  ::uint64_t getF();
  inline void setF( ::uint64_t value);

  inline  ::uint64_t getG();
  inline void setG( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bytes56::Pipeline {
public:
  typedef Bytes56 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PublicKey::Reader {
public:
  typedef PublicKey Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isX25519() const;
  inline typename X25519::Reader getX25519() const;

  inline bool isX448() const;
  inline typename X448::Reader getX448() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PublicKey::Builder {
public:
  typedef PublicKey Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isX25519();
  inline typename X25519::Builder getX25519();
  inline typename X25519::Builder initX25519();

  inline bool isX448();
  inline typename X448::Builder getX448();
  inline typename X448::Builder initX448();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PublicKey::Pipeline {
public:
  typedef PublicKey Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PublicKey::X25519::Reader {
public:
  typedef X25519 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBytes() const;
  inline  ::capnp::rpc::noise::Bytes32::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PublicKey::X25519::Builder {
public:
  typedef X25519 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBytes();
  inline  ::capnp::rpc::noise::Bytes32::Builder getBytes();
  inline void setBytes( ::capnp::rpc::noise::Bytes32::Reader value);
  inline  ::capnp::rpc::noise::Bytes32::Builder initBytes();
  inline void adoptBytes(::capnp::Orphan< ::capnp::rpc::noise::Bytes32>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes32> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PublicKey::X25519::Pipeline {
public:
  typedef X25519 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::Bytes32::Pipeline getBytes();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PublicKey::X448::Reader {
public:
  typedef X448 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBytes() const;
  inline  ::capnp::rpc::noise::Bytes56::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PublicKey::X448::Builder {
public:
  typedef X448 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBytes();
  inline  ::capnp::rpc::noise::Bytes56::Builder getBytes();
  inline void setBytes( ::capnp::rpc::noise::Bytes56::Reader value);
  inline  ::capnp::rpc::noise::Bytes56::Builder initBytes();
  inline void adoptBytes(::capnp::Orphan< ::capnp::rpc::noise::Bytes56>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes56> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PublicKey::X448::Pipeline {
public:
  typedef X448 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::Bytes56::Pipeline getBytes();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatId::Reader {
public:
  typedef VatId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPublicKey() const;
  inline  ::capnp::rpc::noise::PublicKey::Reader getPublicKey() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatId::Builder {
public:
  typedef VatId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPublicKey();
  inline  ::capnp::rpc::noise::PublicKey::Builder getPublicKey();
  inline void setPublicKey( ::capnp::rpc::noise::PublicKey::Reader value);
  inline  ::capnp::rpc::noise::PublicKey::Builder initPublicKey();
  inline void adoptPublicKey(::capnp::Orphan< ::capnp::rpc::noise::PublicKey>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::PublicKey> disownPublicKey();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatId::Pipeline {
public:
  typedef VatId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::PublicKey::Pipeline getPublicKey();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ProvisionId::Reader {
public:
  typedef ProvisionId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasProviderVatId() const;
  inline  ::capnp::rpc::noise::VatId::Reader getProviderVatId() const;

  inline  ::uint64_t getNonce() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ProvisionId::Builder {
public:
  typedef ProvisionId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasProviderVatId();
  inline  ::capnp::rpc::noise::VatId::Builder getProviderVatId();
  inline void setProviderVatId( ::capnp::rpc::noise::VatId::Reader value);
  inline  ::capnp::rpc::noise::VatId::Builder initProviderVatId();
  inline void adoptProviderVatId(::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> disownProviderVatId();

  inline  ::uint64_t getNonce();
  inline void setNonce( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ProvisionId::Pipeline {
public:
  typedef ProvisionId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::VatId::Pipeline getProviderVatId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RecipientId::Reader {
public:
  typedef RecipientId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRecipientVatId() const;
  inline  ::capnp::rpc::noise::VatId::Reader getRecipientVatId() const;

  inline  ::uint64_t getNonce() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RecipientId::Builder {
public:
  typedef RecipientId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRecipientVatId();
  inline  ::capnp::rpc::noise::VatId::Builder getRecipientVatId();
  inline void setRecipientVatId( ::capnp::rpc::noise::VatId::Reader value);
  inline  ::capnp::rpc::noise::VatId::Builder initRecipientVatId();
  inline void adoptRecipientVatId(::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> disownRecipientVatId();

  inline  ::uint64_t getNonce();
  inline void setNonce( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RecipientId::Pipeline {
public:
  typedef RecipientId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::VatId::Pipeline getRecipientVatId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatAddress::Reader {
public:
  typedef VatAddress Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isIpv6() const;
  inline typename Ipv6::Reader getIpv6() const;

  inline bool isIpv4() const;
  inline typename Ipv4::Reader getIpv4() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatAddress::Builder {
public:
  typedef VatAddress Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isIpv6();
  inline typename Ipv6::Builder getIpv6();
  inline typename Ipv6::Builder initIpv6();

  inline bool isIpv4();
  inline typename Ipv4::Builder getIpv4();
  inline typename Ipv4::Builder initIpv4();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatAddress::Pipeline {
public:
  typedef VatAddress Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatAddress::Ipv6::Reader {
public:
  typedef Ipv6 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBytes() const;
  inline  ::capnp::rpc::noise::Bytes16::Reader getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatAddress::Ipv6::Builder {
public:
  typedef Ipv6 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBytes();
  inline  ::capnp::rpc::noise::Bytes16::Builder getBytes();
  inline void setBytes( ::capnp::rpc::noise::Bytes16::Reader value);
  inline  ::capnp::rpc::noise::Bytes16::Builder initBytes();
  inline void adoptBytes(::capnp::Orphan< ::capnp::rpc::noise::Bytes16>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes16> disownBytes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatAddress::Ipv6::Pipeline {
public:
  typedef Ipv6 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::Bytes16::Pipeline getBytes();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VatAddress::Ipv4::Reader {
public:
  typedef Ipv4 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getBytes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VatAddress::Ipv4::Builder {
public:
  typedef Ipv4 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getBytes();
  inline void setBytes( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VatAddress::Ipv4::Pipeline {
public:
  typedef Ipv4 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ThirdPartyCapId::Reader {
public:
  typedef ThirdPartyCapId Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAddress() const;
  inline  ::capnp::rpc::noise::VatAddress::Reader getAddress() const;

  inline bool hasVatId() const;
  inline  ::capnp::rpc::noise::VatId::Reader getVatId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ThirdPartyCapId::Builder {
public:
  typedef ThirdPartyCapId Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAddress();
  inline  ::capnp::rpc::noise::VatAddress::Builder getAddress();
  inline void setAddress( ::capnp::rpc::noise::VatAddress::Reader value);
  inline  ::capnp::rpc::noise::VatAddress::Builder initAddress();
  inline void adoptAddress(::capnp::Orphan< ::capnp::rpc::noise::VatAddress>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::VatAddress> disownAddress();

  inline bool hasVatId();
  inline  ::capnp::rpc::noise::VatId::Builder getVatId();
  inline void setVatId( ::capnp::rpc::noise::VatId::Reader value);
  inline  ::capnp::rpc::noise::VatId::Builder initVatId();
  inline void adoptVatId(::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value);
  inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> disownVatId();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ThirdPartyCapId::Pipeline {
public:
  typedef ThirdPartyCapId Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::rpc::noise::VatAddress::Pipeline getAddress();
  inline  ::capnp::rpc::noise::VatId::Pipeline getVatId();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class JoinResult::Reader {
public:
  typedef JoinResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class JoinResult::Builder {
public:
  typedef JoinResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class JoinResult::Pipeline {
public:
  typedef JoinResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t Bytes16::Reader::getA() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes16::Builder::getA() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bytes16::Builder::setA( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes16::Reader::getB() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes16::Builder::getB() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bytes16::Builder::setB( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes32::Reader::getA() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes32::Builder::getA() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bytes32::Builder::setA( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes32::Reader::getB() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes32::Builder::getB() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bytes32::Builder::setB( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes32::Reader::getC() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes32::Builder::getC() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Bytes32::Builder::setC( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes32::Reader::getD() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes32::Builder::getD() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Bytes32::Builder::setD( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getA() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getA() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setA( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getB() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getB() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setB( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getC() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getC() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setC( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getD() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getD() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setD( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getE() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getE() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setE( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getF() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getF() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setF( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Bytes56::Reader::getG() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Bytes56::Builder::getG() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Bytes56::Builder::setG( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::rpc::noise::PublicKey::Which PublicKey::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnp::rpc::noise::PublicKey::Which PublicKey::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool PublicKey::Reader::isX25519() const {
  return which() == PublicKey::X25519;
}
inline bool PublicKey::Builder::isX25519() {
  return which() == PublicKey::X25519;
}
inline typename PublicKey::X25519::Reader PublicKey::Reader::getX25519() const {
  KJ_IREQUIRE((which() == PublicKey::X25519),
              "Must check which() before get()ing a union member.");
  return typename PublicKey::X25519::Reader(_reader);
}
inline typename PublicKey::X25519::Builder PublicKey::Builder::getX25519() {
  KJ_IREQUIRE((which() == PublicKey::X25519),
              "Must check which() before get()ing a union member.");
  return typename PublicKey::X25519::Builder(_builder);
}
inline typename PublicKey::X25519::Builder PublicKey::Builder::initX25519() {
  _builder.setDataField<PublicKey::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PublicKey::X25519);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename PublicKey::X25519::Builder(_builder);
}
inline bool PublicKey::Reader::isX448() const {
  return which() == PublicKey::X448;
}
inline bool PublicKey::Builder::isX448() {
  return which() == PublicKey::X448;
}
inline typename PublicKey::X448::Reader PublicKey::Reader::getX448() const {
  KJ_IREQUIRE((which() == PublicKey::X448),
              "Must check which() before get()ing a union member.");
  return typename PublicKey::X448::Reader(_reader);
}
inline typename PublicKey::X448::Builder PublicKey::Builder::getX448() {
  KJ_IREQUIRE((which() == PublicKey::X448),
              "Must check which() before get()ing a union member.");
  return typename PublicKey::X448::Builder(_builder);
}
inline typename PublicKey::X448::Builder PublicKey::Builder::initX448() {
  _builder.setDataField<PublicKey::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, PublicKey::X448);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename PublicKey::X448::Builder(_builder);
}
inline bool PublicKey::X25519::Reader::hasBytes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PublicKey::X25519::Builder::hasBytes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::Bytes32::Reader PublicKey::X25519::Reader::getBytes() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::Bytes32::Builder PublicKey::X25519::Builder::getBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::Bytes32::Pipeline PublicKey::X25519::Pipeline::getBytes() {
  return  ::capnp::rpc::noise::Bytes32::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PublicKey::X25519::Builder::setBytes( ::capnp::rpc::noise::Bytes32::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::Bytes32::Builder PublicKey::X25519::Builder::initBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PublicKey::X25519::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::rpc::noise::Bytes32>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes32> PublicKey::X25519::Builder::disownBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes32>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PublicKey::X448::Reader::hasBytes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PublicKey::X448::Builder::hasBytes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::Bytes56::Reader PublicKey::X448::Reader::getBytes() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::Bytes56::Builder PublicKey::X448::Builder::getBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::Bytes56::Pipeline PublicKey::X448::Pipeline::getBytes() {
  return  ::capnp::rpc::noise::Bytes56::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PublicKey::X448::Builder::setBytes( ::capnp::rpc::noise::Bytes56::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::Bytes56::Builder PublicKey::X448::Builder::initBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PublicKey::X448::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::rpc::noise::Bytes56>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes56> PublicKey::X448::Builder::disownBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes56>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VatId::Reader::hasPublicKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VatId::Builder::hasPublicKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::PublicKey::Reader VatId::Reader::getPublicKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::PublicKey::Builder VatId::Builder::getPublicKey() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::PublicKey::Pipeline VatId::Pipeline::getPublicKey() {
  return  ::capnp::rpc::noise::PublicKey::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VatId::Builder::setPublicKey( ::capnp::rpc::noise::PublicKey::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::PublicKey::Builder VatId::Builder::initPublicKey() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VatId::Builder::adoptPublicKey(
    ::capnp::Orphan< ::capnp::rpc::noise::PublicKey>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::PublicKey> VatId::Builder::disownPublicKey() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::PublicKey>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ProvisionId::Reader::hasProviderVatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ProvisionId::Builder::hasProviderVatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::VatId::Reader ProvisionId::Reader::getProviderVatId() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::VatId::Builder ProvisionId::Builder::getProviderVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::VatId::Pipeline ProvisionId::Pipeline::getProviderVatId() {
  return  ::capnp::rpc::noise::VatId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ProvisionId::Builder::setProviderVatId( ::capnp::rpc::noise::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::VatId::Builder ProvisionId::Builder::initProviderVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ProvisionId::Builder::adoptProviderVatId(
    ::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> ProvisionId::Builder::disownProviderVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t ProvisionId::Reader::getNonce() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t ProvisionId::Builder::getNonce() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ProvisionId::Builder::setNonce( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool RecipientId::Reader::hasRecipientVatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RecipientId::Builder::hasRecipientVatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::VatId::Reader RecipientId::Reader::getRecipientVatId() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::VatId::Builder RecipientId::Builder::getRecipientVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::VatId::Pipeline RecipientId::Pipeline::getRecipientVatId() {
  return  ::capnp::rpc::noise::VatId::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RecipientId::Builder::setRecipientVatId( ::capnp::rpc::noise::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::VatId::Builder RecipientId::Builder::initRecipientVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RecipientId::Builder::adoptRecipientVatId(
    ::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> RecipientId::Builder::disownRecipientVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t RecipientId::Reader::getNonce() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t RecipientId::Builder::getNonce() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RecipientId::Builder::setNonce( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::capnp::rpc::noise::VatAddress::Which VatAddress::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::capnp::rpc::noise::VatAddress::Which VatAddress::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool VatAddress::Reader::isIpv6() const {
  return which() == VatAddress::IPV6;
}
inline bool VatAddress::Builder::isIpv6() {
  return which() == VatAddress::IPV6;
}
inline typename VatAddress::Ipv6::Reader VatAddress::Reader::getIpv6() const {
  KJ_IREQUIRE((which() == VatAddress::IPV6),
              "Must check which() before get()ing a union member.");
  return typename VatAddress::Ipv6::Reader(_reader);
}
inline typename VatAddress::Ipv6::Builder VatAddress::Builder::getIpv6() {
  KJ_IREQUIRE((which() == VatAddress::IPV6),
              "Must check which() before get()ing a union member.");
  return typename VatAddress::Ipv6::Builder(_builder);
}
inline typename VatAddress::Ipv6::Builder VatAddress::Builder::initIpv6() {
  _builder.setDataField<VatAddress::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, VatAddress::IPV6);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename VatAddress::Ipv6::Builder(_builder);
}
inline bool VatAddress::Reader::isIpv4() const {
  return which() == VatAddress::IPV4;
}
inline bool VatAddress::Builder::isIpv4() {
  return which() == VatAddress::IPV4;
}
inline typename VatAddress::Ipv4::Reader VatAddress::Reader::getIpv4() const {
  KJ_IREQUIRE((which() == VatAddress::IPV4),
              "Must check which() before get()ing a union member.");
  return typename VatAddress::Ipv4::Reader(_reader);
}
inline typename VatAddress::Ipv4::Builder VatAddress::Builder::getIpv4() {
  KJ_IREQUIRE((which() == VatAddress::IPV4),
              "Must check which() before get()ing a union member.");
  return typename VatAddress::Ipv4::Builder(_builder);
}
inline typename VatAddress::Ipv4::Builder VatAddress::Builder::initIpv4() {
  _builder.setDataField<VatAddress::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, VatAddress::IPV4);
  _builder.setDataField< ::uint32_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename VatAddress::Ipv4::Builder(_builder);
}
inline bool VatAddress::Ipv6::Reader::hasBytes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VatAddress::Ipv6::Builder::hasBytes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::Bytes16::Reader VatAddress::Ipv6::Reader::getBytes() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::Bytes16::Builder VatAddress::Ipv6::Builder::getBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::Bytes16::Pipeline VatAddress::Ipv6::Pipeline::getBytes() {
  return  ::capnp::rpc::noise::Bytes16::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VatAddress::Ipv6::Builder::setBytes( ::capnp::rpc::noise::Bytes16::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::Bytes16::Builder VatAddress::Ipv6::Builder::initBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VatAddress::Ipv6::Builder::adoptBytes(
    ::capnp::Orphan< ::capnp::rpc::noise::Bytes16>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::Bytes16> VatAddress::Ipv6::Builder::disownBytes() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::Bytes16>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t VatAddress::Ipv4::Reader::getBytes() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t VatAddress::Ipv4::Builder::getBytes() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void VatAddress::Ipv4::Builder::setBytes( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool ThirdPartyCapId::Reader::hasAddress() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ThirdPartyCapId::Builder::hasAddress() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::VatAddress::Reader ThirdPartyCapId::Reader::getAddress() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::VatAddress::Builder ThirdPartyCapId::Builder::getAddress() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::VatAddress::Pipeline ThirdPartyCapId::Pipeline::getAddress() {
  return  ::capnp::rpc::noise::VatAddress::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ThirdPartyCapId::Builder::setAddress( ::capnp::rpc::noise::VatAddress::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::VatAddress::Builder ThirdPartyCapId::Builder::initAddress() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ThirdPartyCapId::Builder::adoptAddress(
    ::capnp::Orphan< ::capnp::rpc::noise::VatAddress>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::VatAddress> ThirdPartyCapId::Builder::disownAddress() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatAddress>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ThirdPartyCapId::Reader::hasVatId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ThirdPartyCapId::Builder::hasVatId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::rpc::noise::VatId::Reader ThirdPartyCapId::Reader::getVatId() const {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::rpc::noise::VatId::Builder ThirdPartyCapId::Builder::getVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::capnp::rpc::noise::VatId::Pipeline ThirdPartyCapId::Pipeline::getVatId() {
  return  ::capnp::rpc::noise::VatId::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ThirdPartyCapId::Builder::setVatId( ::capnp::rpc::noise::VatId::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::rpc::noise::VatId::Builder ThirdPartyCapId::Builder::initVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ThirdPartyCapId::Builder::adoptVatId(
    ::capnp::Orphan< ::capnp::rpc::noise::VatId>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::rpc::noise::VatId> ThirdPartyCapId::Builder::disownVatId() {
  return ::capnp::_::PointerHelpers< ::capnp::rpc::noise::VatId>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

CAPNP_END_HEADER

